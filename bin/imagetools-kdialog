#!/usr/bin/bash
#
#  Part of kde-servicemenus-imagetools
#  Copyright (c) 2021-2023 by Marco Nelles <marco at maniatek dot de>
#  (derived from kde-service-menu-reimage Version 2.5, Copyright (C) 2018-2019 Giuseppe Benigno <giuseppe.benigno(at)gmail.com>)
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

readonly progname="$(basename "$0")"

## Check dependencies

kdialog_bin=$(which kdialog)
if [ -z "${kdialog_bin}" ]; then
    echo "kdialog not found. Assuming KDE environment."
    exit 2
fi

magick_bin=$(which magick)
if [ -z "${magick_bin}" ]; then
    "${kdialog_bin}" --icon configure --title "Dependency check failed" --error "ImageMagick not found. Please install."
    exit 2
fi

mogrify_bin=$(which mogrify)
if [ -z "${mogrify_bin}" ]; then
    "${kdialog_bin}" --icon configure --title "Dependency check failed" --error "ImageMagick not found. Please install."
    exit 2
fi

convert_bin=$(which convert)
if [ -z "${convert_bin}" ]; then
    "${kdialog_bin}" --icon configure --title "Dependency check failed" --error "ImageMagick not found. Please install."
    exit 2
fi

exiftool_bin=$(which exiftool)
if [ -z "${exiftool_bin}" ]; then
    "${kdialog_bin}" --icon configure --title "Dependency check failed" --error "ExifTool not found. Please install."
    exit 2
fi

optipng_bin=$(which optipng)
if [ -z "${optipng_bin}" ]; then
    "${optipng_bin}" --icon configure --title "Dependency check failed" --error "OptiPNG not found. Please install."
    exit 2
fi

## Define help text

msg_help_text="
Image tool collection for KDE service menus.

Usage: ${progname} \$command --

Commands:
    help, -h, --help
        Show this help text

    convert <\$format|custom>
        Convert the image to the desired format. A complete list
        can be obtained with: \"mogrify -list format\".

    resize <\$percent|\$pixel|custom>
        Resize image file. Give scale factor in percentage or
        the maximum size in pixel for the longer edge. Values
        can be e.g. \"50%\" or \"1920px\".
    rotate <\$angle|auto>
        Rotate the image by the desired angle in degree. Postive
        values rotate to the right, negative values to the left.
        Values can be e.g. \"90\" or \"-90\".
    mirror <flip|flop>
        Mirror image. flip: mirror in the vertical axis, flop:
        mirror in the horizintal axis.

    jpeg_makeprogressive
        Encode JPEG progressive
    jpeg_optimize
        Optimize JPEG encoding with quality value 80% (lossy)
    jpeg_weboptimize
        Resize JPEG to 1920px on the longer side (max. FullHD),
        optimize JPEG encoding with quality value 80% (lossy) and
        remove all unnecessary metadata (strip)
    jpeg_reencode <\$percent|custom>
        Reencode JPEG with new quality value
    jpeg_reencode_psnr <\$psnr|custom>
        Reencode with lowest quality value with PSNR >= \$psnr (lossy and slow)

    png_optimize
        Optimize PNG encoding (lossless)

    strip
        Remove all unnecessary metadata

    gen_icon
        generate icon (format PNG, size: 360x360px)
    gen_icon_rectangle
        generate icon (format PNG, size: 440x360px)
    gen_favicon
        generate favicon

Examples:
    ${progname} jpeg_optimize /path/to/image1.jpg /path/to/image2.jpg
    ${progname} jpeg_reencode 50% /path/to/image1.jpg
    ${progname} resize 1920p /path/to/image1.jpg
    ${progname} resize custom /path/to/image1.jpg
"

## Exec functions

exec_convert() {

    local inputfile="$1"
    local format="$FORMAT"

    local dir
    dir=$(dirname -- "${inputfile}")
    local name="${inputfile##*/}"
    local base="${name%.*}"
    local ext="${name##*.}"

    if [ "${ext}" != "${format}" ]; then
        OUTPUT=$("${mogrify_bin}" -format "${format}" "${inputfile}" 2>&1)
    fi

    return $?

}

exec_resize() {

    local inputfile="$1"
    local scale_factor="$SCALE_FACTOR"

    local dir
    dir=$(dirname -- "${inputfile}")
    local name="${inputfile##*/}"
    local base="${name%.*}"
    local ext="${name##*.}"

    if [ "${scale_factor: -1}" == "%" ]; then
        if [ "${overwrite}" = true ]; then
            OUTPUT=$("${mogrify_bin}" -resize "${scale_factor}" "${inputfile}" 2>&1)
        else
            OUTPUT=$("${convert_bin}" -resize "${scale_factor}" "${inputfile}" "${dir}/${base}_resized_${scale_factor}.${ext}" 2>&1)
        fi
    elif [ "${scale_factor: -2}" == "px" ]; then
        scale_factor=${scale_factor::-2}
        if [ "${overwrite}" = true ]; then
            OUTPUT=$("${mogrify_bin}" -resize "${scale_factor}x${scale_factor}>" "${inputfile}" 2>&1)
        else
            OUTPUT=$("${convert_bin}" -resize "${scale_factor}x${scale_factor}>" "${inputfile}" "${dir}/${base}_resized_${scale_factor}p.${ext}" 2>&1)
        fi
    fi

    return $?

}

exec_rotate() {

    local inputfile="$1"
    local angle="$ANGLE"

    local dir
    dir=$(dirname -- "${inputfile}")
    local name="${inputfile##*/}"
    local base="${name%.*}"
    local ext="${name##*.}"

    if [ "${overwrite}" = true ]; then
        if [ "${angle}" = "auto" ]; then
            OUTPUT=$("${mogrify_bin}" -auto-orient "${inputfile}" 2>&1)
        else
            OUTPUT=$("${mogrify_bin}" -rotate "${angle}" "${inputfile}" 2>&1)
        fi
    else
        if [ "${angle}" = "auto" ]; then
            OUTPUT=$("${convert_bin}" -auto-orient "${inputfile}" "${dir}/${base}_rotated_${angle}°.${ext}" 2>&1)
        else
            OUTPUT=$("${convert_bin}" -rotate "${angle}" "${inputfile}" "${dir}/${base}_rotated_${angle}°.${ext}" 2>&1)
        fi
    fi

    return $?

}

exec_mirror() {

    local inputfile="$1"
    local mirrordirection="$MIRRORDIRECTION"

    local dir
    dir=$(dirname -- "${inputfile}")
    local name="${inputfile##*/}"
    local base="${name%.*}"
    local ext="${name##*.}"

    if [ "${overwrite}" = true ]; then
        OUTPUT=$("${mogrify_bin}" -"${mirrordirection}" "${inputfile}" 2>&1)
    else
        OUTPUT=$("${convert_bin}" -"${mirrordirection}" "${inputfile}" "${dir}/${base}_${mirrordirection}.${ext}" 2>&1)
    fi

    return $?

}

exec_jpeg_reencode() {

    local inputfile="$1"
    local quality="$JPEG_QUALITY"

    local dir
    dir=$(dirname -- "${inputfile}")
    local name="${inputfile##*/}"
    local base="${name%.*}"
    local ext="${name##*.}"

    if [ "${overwrite}" = true ]; then
        OUTPUT=$("${mogrify_bin}" -quality "${quality}" "${inputfile}" 2>&1)
    else
        OUTPUT=$("${convert_bin}" -quality "${quality}" "${inputfile}" "${dir}/${base}_reencoded_${quality}.${ext}" 2>&1)
    fi

    return $?
}

exec_jpeg_reencode_psnr() {

    local inputfile="$1"
    local psnr="$PSNR"

    local dir
    dir=$(dirname -- "${inputfile}")
    local name="${inputfile##*/}"
    local base="${name%.*}"
    local ext="${name##*.}"

    local tmpfile
    tmpfile=$(mktemp -p "${dir}" --suffix=".${ext}")

    local q
    local prev_tf
    for q in 84 82 80 78 76 74 72 70 68 66 64 62 60 58 56 54 52 50 48 46 44 42 40 38 36 34; do

        tf=$(mktemp -p "${dir}" --suffix=".${ext}")
        OUTPUT=$("${convert_bin}" -filter Triangle -define filter:support=2 -unsharp 0.25x0.25+8+0.065 -dither None -posterize 136 -quality $q -define jpeg:fancy-upsampling=off -colorspace sRGB -strip -interlace Plane "${inputfile}" "${tf}" 2>&1)
        rc=$?
        if [ $rc -ne 0 ]; then
          [ -f "${prev_tf}" ] && rm -f "${prev_tf}"
          [ -f "${tf}" ] && rm -f "${tf}"
          [ -f "${tmpfile}" ] && rm -f "${tmpfile}"
          return $rc
        fi

        if [ $q -eq 34 ]; then
            cp "${tf}" "${tmpfile}"
            break
        fi

        p=$(${magick_bin} compare -metric PSNR "${inputfile}" "${tf}" null: 2>&1)
        rc=$?
        if [ $rc -gt 1 ]; then
          [ -f "${prev_tf}" ] && rm -f "${prev_tf}"
          [ -f "${tf}" ] && rm -f "${tf}"
          [ -f "${tmpfile}" ] && rm -f "${tmpfile}"
          return $rc
        fi

        p=${p#*\(}
        p=${p%*\)}

        if (( $(echo "$p*100 < $psnr" | bc -l) )); then
            if [ -z "${prev_tf}" ]; then
                echo "No reencoding without visual loss by PSNR advisable."
                [ -f "${tf}" ] && rm -f "${tf}"
                [ -f "${tmpfile}" ] && rm -f "${tmpfile}"
                return 0
            fi
            cp "${prev_tf}" "${tmpfile}"
            break
        fi

        [ -n "${prev_tf}" ] && rm -f "${prev_tf}"
        prev_tf="${tf}"

    done

    [ -f "${prev_tf}" ] && rm -f "${prev_tf}"
    [ -f "${tf}" ] && rm -f "${tf}"

    if [ "${overwrite}" = true ]; then
        rm "${inputfile}"
        mv "${tmpfile}" "${inputfile}"
    else
        mv "${tmpfile}" "${dir}/${base}_reencoded_${q}.${ext}"
    fi

    return 0

}

exec_jpeg_optimize() {

    local inputfile="$1"

    local dir
    dir=$(dirname -- "${inputfile}")
    local name="${inputfile##*/}"
    local base="${name%.*}"
    local ext="${name##*.}"

    ## https://www.smashingmagazine.com/2015/06/efficient-image-resizing-with-imagemagick/
    if [ "${overwrite}" = true ]; then
        OUTPUT=$("${mogrify_bin}" -filter Triangle -define filter:support=2 -unsharp 0.25x0.25+8+0.065 -dither None -posterize 136 -quality 80 -define jpeg:fancy-upsampling=off -colorspace sRGB -strip -interlace Plane "${inputfile}" 2>&1)
    else
        OUTPUT=$("${convert_bin}" -filter Triangle -define filter:support=2 -unsharp 0.25x0.25+8+0.065 -dither None -posterize 136 -quality 80 -define jpeg:fancy-upsampling=off -colorspace sRGB -strip -interlace Plane "${inputfile}" "${dir}/${base}_optimized.${ext}" 2>&1)
    fi

    return $?

}

exec_jpeg_weboptimize() {

    local inputfile="$1"

    local dir
    dir=$(dirname -- "${inputfile}")
    local name="${inputfile##*/}"
    local base="${name%.*}"
    local ext="${name##*.}"

    local tmpfile
    tmpfile=$(mktemp -p "${dir}" --suffix "${ext}")

    OUTPUT=$("${convert_bin}" -resize "1920x1920>" "${inputfile}" "${tmpfile}" 2>&1)
    rc=$?
    if [ $rc -ne 0 ]; then
        rm "${tmpfile}"
        return $rc
    fi

    OUTPUT=$("${mogrify_bin}" -filter Triangle -define filter:support=2 -unsharp 0.25x0.25+8+0.065 -dither None -posterize 136 -quality 80 -define jpeg:fancy-upsampling=off -colorspace sRGB -strip -interlace Plane "${tmpfile}" 2>&1)
    rc=$?
    if [ $rc -ne 0 ]; then
        rm "${tmpfile}"
        return $rc
    fi

    OUTPUT=$("${exiftool_bin}" -all= -overwrite_original -r "${tmpfile}" 2>&1)
    rc=$?
    if [ $rc -ne 0 ]; then
        rm "${tmpfile}"
        return $rc
    fi

    if [ "${overwrite}" = true ]; then
        rm "${inputfile}"
        mv "${tmpfile}" "${inputfile}"
    else
        mv "${tmpfile}" "${dir}/${base}_weboptimized.${ext}"
    fi

    return 0

}

exec_jpeg_makeprogressive() {

    local inputfile="$1"

    local dir
    dir=$(dirname -- "${inputfile}")
    local name="${inputfile##*/}"
    local base="${name%.*}"
    local ext="${name##*.}"

    if [ "${overwrite}" = true ]; then
        OUTPUT=$("${mogrify_bin}" -strip -interlace Plane "${inputfile}" 2>&1)
    else
        OUTPUT=$("${convert_bin}" -strip -interlace Plane "${inputfile}" "${dir}/${base}_progressive.${ext}" 2>&1)
    fi

    return $?

}

exec_png_optimize() {

    local inputfile="$1"

    local dir
    dir=$(dirname -- "${inputfile}")
    local name="${inputfile##*/}"
    local base="${name%.*}"
    local ext="${name##*.}"

    if [ "${overwrite}" = true ]; then
        OUTPUT=$("${optipng_bin}" "${inputfile}" 2>&1)
    else
        OUTPUT=$("${optipng_bin}" -out "${dir}/${base}_optimized.${ext}" "${inputfile}" 2>&1)
    fi

    return $?

}

exec_strip() {

    local inputfile="$1"

    OUTPUT=$("${exiftool_bin}" -all= -overwrite_original -r "${inputfile}" 2>&1)

    return $?

}

exec_gen_icon() {

    local inputfile="$1"

    local dir
    dir=$(dirname -- "${inputfile}")
    local name="${inputfile##*/}"
    local base="${name%.*}"
    local ext="${name##*.}"

    OUTPUT=$("${convert_bin}" -format png -resize 288x288 -gravity center -background white -extent 360x360 "${inputfile}" "${dir}/${base}_icon.png" 2>&1)
    rc=$?
    if [ $rc -ne 0 ]; then
        return $rc
    fi

    OUTPUT=$("${optipng_bin}" "${dir}/${base}_icon.png" 2>&1)

    return $?

}

exec_gen_icon_rectangle() {

    local inputfile="$1"

    local dir
    dir=$(dirname -- "${inputfile}")
    local name="${inputfile##*/}"
    local base="${name%.*}"
    local ext="${name##*.}"

    OUTPUT=$("${convert_bin}" -format png -resize 352x288 -gravity center -background white -extent 440x360 "${inputfile}" "${dir}/${base}_icon.png" 2>&1)
    rc=$?
    if [ $rc -ne 0 ]; then
        return $rc
    fi

    OUTPUT=$("${optipng_bin}" "${dir}/${base}_icon.png" 2>&1)

    return $?

}

exec_gen_favicon() {

    local inputfile="$1"

    local dir
    dir=$(dirname -- "${inputfile}")
    local name="${inputfile##*/}"
    local base="${name%.*}"
    local ext="${name##*.}"

    local wxh
    wxh=$(convert "${inputfile}" -format "%w x %h" info:)
    local w=${wxh%% *}
    local h=${wxh##* }
    local max=$((w > h ? w : h))

    local tmpfile
    tmpfile=$(mktemp -p "${dir}" --suffix png)

    OUTPUT=$("${convert_bin}" -background transparent -compose Copy -gravity center -extent ${max}x${max} "${inputfile}" "${tmpfile}" 2>&1)
    rc=$?
    if [ $rc -ne 0 ]; then
        rm "${tmpfile}"
        return $rc
    fi

    OUTPUT=$("${convert_bin}" -define icon:auto-resize=64,48,32,16 "${tmpfile}" "${dir}/${base}_favicon.ico" 2>&1)
    rc=$?
    if [ $rc -ne 0 ]; then
        rm "${tmpfile}"
        return $rc
    fi

    rm "${tmpfile}"

    return 0

}

overwrite_question() {

    "${kdialog_bin}" --icon configure --title "${msg_title}" --warningyesno "In case the images to be saved have the same name as those to be processed.\nDo you want to overwrite them?"
    rc=$?

    if [ $rc -eq 0 ]; then
        overwrite=true
    else
        if [ $rc -eq 1 ]; then
            overwrite=false
        else
            {
                "${kdialog_bin}" --title "${msg_title}" --passivepopup "Operation interrupted by the user." 5
                exit 2
            }
        fi
    fi

}

iterate_files() {

    if [ "${flag_ask_overwrite}" = true ]; then
        overwrite_question
    fi

    file_count=$#
    dbus_ref=$(${kdialog_bin} --icon configure --title "${msg_title}" --progressbar "Starting." $file_count)
    qdbus $dbus_ref org.kde.kdialog.ProgressDialog.showCancelButton true
    i=1

    while [[ "false" == "$(qdbus $dbus_ref org.kde.kdialog.ProgressDialog.wasCancelled 2>/dev/null)" && $i -le $file_count ]]; do

        local file="${!i}"
        local basename_file
        basename_file="$(basename "$file")"

        if [ ! -f "${file}" ]; then
            "${kdialog_bin}" --title --icon configure "${msg_title}" --error "File $basename_file not found."
            break
        fi
        qdbus $dbus_ref org.kde.kdialog.ProgressDialog.setLabelText "Processing file $i of $file_count ($basename_file)"

        case $command in
        convert)
            exec_convert "${file}"
            ;;
        resize)
            exec_resize "${file}"
            ;;
        rotate)
            exec_rotate "${file}"
            ;;
        mirror)
            exec_mirror "${file}"
            ;;
        jpeg_makeprogressive)
            exec_jpeg_makeprogressive "${file}"
            ;;
        jpeg_optimize)
            exec_jpeg_optimize "${file}"
            ;;
        jpeg_weboptimize)
            exec_jpeg_weboptimize "${file}"
            ;;
        jpeg_reencode)
            exec_jpeg_reencode "${file}"
            ;;
        jpeg_reencode_psnr)
            exec_jpeg_reencode_psnr "${file}"
            ;;
        png_optimize)
            exec_png_optimize "${file}"
            ;;
        strip)
            exec_strip "${file}"
            ;;
        gen_icon)
            exec_gen_icon "${file}"
            ;;
        gen_icon_rectangle)
            exec_gen_icon_rectangle "${file}"
            ;;
        gen_favicon)
            exec_gen_favicon "${file}"
            ;;
        esac

        rc=$?
        if [ $rc -eq 0 ]; then
            "${kdialog_bin}" --title "${msg_title}" --passivepopup "Done." 5
        else
            {
                qdbus $dbus_ref close
                "${kdialog_bin}" --icon configure --title "${msg_title}" --detailederror "An error has occurred." "${OUTPUT}"
                exit 2
            }
        fi

        qdbus $dbus_ref org.freedesktop.DBus.Properties.Set org.kde.kdialog.ProgressDialog value $i

        i=$((i + 1))

    done

    qdbus $dbus_ref close 2>/dev/null

}

## init functions

init_convert() {

    value="${1}"
    shift

    FORMAT="png"
    if [ "${value}" = "custom" ]; then
        FORMAT=$("${kdialog_bin}" --icon configure --title "${msg_title}" --inputbox "Type the format you want.\nA complete list can be obtained from the shell with: mogrify -list format\nor by consulting the ImageMagick manual.") ||
            { "${kdialog_bin}" --title "${msg_title}" --passivepopup "Cancel" 5 && exit 2; }
    else
        FORMAT="${value}"
    fi

    iterate_files "${@}"

}

init_resize() {

    value="${1}"
    shift

    SCALE_FACTOR="50%"
    if [ "${value}" = "custom" ]; then
        SCALE_FACTOR=$("${kdialog_bin}" --icon configure --title "${msg_title}" --inputbox "Type the scale factor in percentage or the maximum size in pixel you want for the longer edge.\nValid values can be: 50% or 1920p:") ||
            { "${kdialog_bin}" --title "${msg_title}" --passivepopup "Cancel" 5 && exit 2; }
    else
        SCALE_FACTOR="${value}"
    fi

    flag_ask_overwrite=true
    iterate_files "${@}"

}

init_rotate() {

    value="${1}"
    shift

    ANGLE="90"
    if [ "${value}" = "custom" ]; then
        ANGLE=$("${kdialog_bin}" --icon configure --title "${msg_title}" --inputbox "Enter the desired rotation angle in degree:") ||
            { "${kdialog_bin}" --title "${msg_title}" --passivepopup "Cancel" 5 && exit 2; }
    else
        ANGLE="${value}"
    fi

    flag_ask_overwrite=true
    iterate_files "${@}"

}

init_mirror() {

    value="${1}"
    shift

    MIRRORDIRECTION="${value}"

    flag_ask_overwrite=true
    iterate_files "${@}"

}

init_jpeg_reencode() {

    value="${1}"
    shift

    JPEG_QUALITY="70%"
    if [ "${value}" = "custom" ]; then
        JPEG_QUALITY=$("${kdialog_bin}" --icon configure --title "${msg_title}" --inputbox "Type the quality in percent:" "${JPEG_QUALITY}") ||
            { "${kdialog_bin}" --title "${msg_title}" --passivepopup "Cancel" 5 && exit 2; }
    else
        JPEG_QUALITY="${value}"
    fi

    flag_ask_overwrite=true
    iterate_files "${@}"

}

init_jpeg_reencode_psnr() {

    value="${1}"
    shift

    PSNR="35"
    if [ "${value}" = "custom" ]; then
        PSNR=$("${kdialog_bin}" --icon configure --title "${msg_title}" --inputbox "Type the PSNR target value:" "${PSNR}") ||
            { "${kdialog_bin}" --title "${msg_title}" --passivepopup "Cancel" 5 && exit 2; }
    else
        PSNR="${value}"
    fi

    flag_ask_overwrite=true
    iterate_files "${@}"

}

init_jpeg_optimize() {

    flag_ask_overwrite=true
    iterate_files "${@}"

}

init_jpeg_weboptimize() {

    flag_ask_overwrite=true
    iterate_files "${@}"

}

init_jpeg_makeprogressive() {

    flag_ask_overwrite=true
    iterate_files "${@}"

}

init_png_optimize() {

    flag_ask_overwrite=true
    iterate_files "${@}"

}

init_strip() {

    iterate_files "${@}"

}

init_gen_icon() {

    iterate_files "${@}"

}

init_gen_icon_rectangle() {

    iterate_files "${@}"

}

init_gen_favicon() {

    iterate_files "${@}"

}

## Main part

command="${1}"
shift

flag_ask_overwrite=false

if [ -z "$command" ]; then
    echo "$msg_help_text"
    exit 0
fi

case $command in
help | -h | --help)
    echo "$msg_help_text"
    exit 0
    ;;
convert)
    msg_title="Convertion of $basename_file"
    init_convert "${@}"
    ;;
resize)
    msg_title="Resizing of $basename_file"
    init_resize "${@}"
    ;;
rotate)
    msg_title="Rotation of $basename_file"
    init_rotate "${@}"
    ;;
mirror)
    msg_title="Mirroring of $basename_file"
    init_mirror "${@}"
    ;;
jpeg_makeprogressive)
    msg_title="Make $basename_file progressive"
    init_jpeg_makeprogressive "${@}"
    ;;
jpeg_optimize)
    msg_title="Optimizing of $basename_file"
    init_jpeg_optimize "${@}"
    ;;
jpeg_weboptimize)
    msg_title="Optimizing of $basename_file for web publishing"
    init_jpeg_weboptimize "${@}"
    ;;
jpeg_reencode)
    msg_title="Reencoding of $basename_file"
    init_jpeg_reencode "${@}"
    ;;
jpeg_reencode_psnr)
    msg_title="Reencoding of $basename_file"
    init_jpeg_reencode_psnr "${@}"
    ;;
png_optimize)
    msg_title="Optimizing of $basename_file"
    init_png_optimize "${@}"
    ;;
strip)
    msg_title="Striping of metadata from $basename_file"
    init_strip "${@}"
    ;;
gen_icon)
    msg_title="Generating icon from $basename_file"
    init_gen_icon "${@}"
    ;;
gen_icon_rectangle)
    msg_title="Generating icon from $basename_file"
    init_gen_icon_rectangle "${@}"
    ;;
gen_favicon)
    msg_title="Generating favicon from $basename_file"
    init_gen_favicon "${@}"
    ;;
*)
    ${kdialog_bin} --icon configure --title "Commandline error" --error "Command ${command} not found. Please install corresponding package."
    exit 2
    ;;
esac

exit 0
